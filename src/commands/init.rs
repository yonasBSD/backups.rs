//! `backup init` — scaffold a `backup.toml` in the current directory.
//!
//! # What it does
//!
//! 1. Reads the current working directory and the active username from the environment.
//! 2. Generates a ready-to-use `backup.toml` with those values pre-filled.
//! 3. Writes the file to the path specified by `--config` (default: `./backup.toml`).
//! 4. Exits with an error if the destination file already exists, to prevent accidental overwrites.
//!
//! # Generated file
//!
//! The generated file is a commented TOML with all supported keys.  Users are
//! expected to open it, read the comments, and adjust paths/passwords before
//! running `backup` for the first time.

use std::path::{Path, PathBuf};

use anyhow::{Context as _, Result};

use crate::ui::StageOutcome;

// ─── Entry point ──────────────────────────────────────────────────────────────

/// Run the `init` subcommand.
///
/// Writes a starter `backup.toml` to `dest`.  Returns an error if the file
/// already exists or if the working directory / username cannot be determined.
pub fn run(dest: &Path) -> Result<()> {
    if dest.exists() {
        let outcome = StageOutcome {
            label: format!(
                "'{}' already exists — refusing to overwrite.\n\
             Delete it manually or use --config to specify a different path.",
                dest.display()
            ),
            success: false,
            stdout: String::new(),
            stderr: String::new(),
            error: None,
        };
        outcome.print();

        anyhow::bail!("");
    }

    let content = generate_config()?;

    std::fs::write(dest, &content).with_context(|| format!("writing '{}'", dest.display()))?;

    let outcome = StageOutcome {
        label: format!("Created '{}'", dest.display()),
        success: true,
        stdout: String::new(),
        stderr: String::new(),
        error: None,
    };
    outcome.print();

    Ok(())
}

// ─── Config generation ────────────────────────────────────────────────────────

/// Resolve runtime values needed to populate the generated config.
struct EnvContext {
    /// Absolute path of the current working directory.
    cwd: String,
    /// Login name of the user running the process.
    username: String,
    /// Last path component of `cwd`; used as the repository directory name.
    repo_name: String,
}

impl EnvContext {
    fn resolve() -> Result<Self> {
        let cwd = std::env::current_dir()
            .context("could not determine current working directory")?
            .to_string_lossy()
            .into_owned();

        // Try $USER first (set by most login shells), fall back to $LOGNAME
        // (POSIX), then give up gracefully with a placeholder.
        let username = std::env::var("USER")
            .or_else(|_| std::env::var("LOGNAME"))
            .unwrap_or_else(|_| "user".into());

        // The last path component makes a good default repo name, e.g.
        // running inside "/home/alice/projects/myapp" → "myapp".
        let repo_name = PathBuf::from(&cwd)
            .file_name()
            .map_or_else(|| "backup".into(), |n| n.to_string_lossy().into_owned());

        Ok(Self {
            cwd,
            username,
            repo_name,
        })
    }
}

/// Generate the full text of a starter `backup.toml`.
///
/// Exposed as a public function so it can be tested independently of the
/// filesystem.
pub fn generate_config() -> Result<String> {
    let ctx = EnvContext::resolve()?;
    Ok(render_template(&ctx.cwd, &ctx.username, &ctx.repo_name))
}

/// Render the TOML template given the three dynamic values.
///
/// Kept separate from `Context::resolve` so tests can call it with
/// controlled inputs without touching the environment.
pub fn render_template(cwd: &str, username: &str, repo_name: &str) -> String {
    format!(
        r#"# backup configuration
# Run with: backup  (reads backup.toml in the current directory)
# Generated by: backup init

[repo]
# Filesystem path (or sftp:/rclone: URI) of the rustic repository.
# The directory will be created automatically on the first run.
path = "/home/{username}/nfs/new-backups/rustic/{repo_name}"
# Encryption password.  Use "" for an unencrypted repository.
# WARNING: do not commit real passwords to version control.
password = ""

[mount]
# Optional: mount a NAS share before backing up.
# The tool will run: [command] [target]  (prefixed with doas if --sudo is set)
# command = "mount-nas"
# target  = "new-backups"

[backup]
# Paths to include in the snapshot.  Defaults to "." if this list is empty.
sources = [
    "{cwd}",
]

# zstd compression level (1 = fastest / largest, 22 = slowest / smallest).
# Level 3 is a good default for mixed source trees.
compression = 3

# Directories that contain a file with this name are skipped entirely.
# Create an empty file called "ignore" in any cache/build/scratch directory
# you never want archived.
exclude_if_present = "ignore"

# Glob patterns forwarded to rustic --glob.
# Patterns starting with "!" exclude matching paths.
globs = [
    "!**/.git",            # Git object store (large, reconstructible)
    "!tmp/",               # Temporary files
    "!**/target/",         # Rust build artefacts
    "!**/node_modules/",   # Node.js dependencies (reinstallable)
    "!**/*.iso",           # Disk images
    "!**/*.swap",          # Swap files
]

[retention]
# How many snapshots to keep when pruning.  rustic selects the most recent
# snapshot within each window.
keep_daily   = 2   # keep one snapshot per day for the last N days
keep_weekly  = 1   # keep one snapshot per week for the last N weeks
keep_monthly = 1   # keep one snapshot per month for the last N months
"#
    )
}

// ─── Tests ────────────────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use std::fs;

    use super::*;

    // ── render_template ───────────────────────────────────────────────────────

    #[test]
    fn template_contains_cwd() {
        let out = render_template("/home/alice/myapp", "alice", "myapp");
        assert!(
            out.contains("/home/alice/myapp"),
            "sources must contain cwd"
        );
    }

    #[test]
    fn template_contains_username() {
        let out = render_template("/home/bob/proj", "bob", "proj");
        assert!(
            out.contains("/home/bob/nfs/new-backups/rustic/proj"),
            "repo path must include username"
        );
    }

    #[test]
    fn template_contains_repo_name() {
        let out = render_template("/srv/apps/widget", "alice", "widget");
        assert!(out.contains("widget"), "repo name must appear in repo path");
    }

    #[test]
    fn template_is_valid_toml() {
        let out = render_template("/tmp/test", "testuser", "test");
        // Strip TOML inline comments before parsing — the `toml` crate
        // handles `# …` comments on their own lines but the version we use
        // can balk at trailing inline comments on value lines.  Strip them
        // so the test stays robust across crate versions.
        let stripped: String = out
            .lines()
            .map(|l| {
                // Keep the whole line unless it has an inline comment after a value.
                if let Some(idx) = l.find("   #") {
                    &l[..idx]
                } else {
                    l
                }
            })
            .collect::<Vec<_>>()
            .join("\n");

        toml::from_str::<toml::Value>(&stripped).expect("rendered template must be valid TOML");
    }

    #[test]
    fn template_has_expected_sections() {
        let out = render_template("/tmp/x", "x", "x");
        for section in &["[repo]", "[mount]", "[backup]", "[retention]"] {
            assert!(out.contains(section), "missing section {section}");
        }
    }

    // ── run ───────────────────────────────────────────────────────────────────

    #[test]
    fn run_creates_file() {
        let dir = tempfile::tempdir().unwrap();
        let dest = dir.path().join("backup.toml");

        run(&dest).expect("init should succeed");

        assert!(dest.exists(), "backup.toml should have been created");
        let content = fs::read_to_string(&dest).unwrap();
        assert!(!content.is_empty());
    }

    #[test]
    fn run_refuses_to_overwrite_existing_file() {
        let dir = tempfile::tempdir().unwrap();
        let dest = dir.path().join("backup.toml");
        fs::write(&dest, "existing content").unwrap();

        let result = run(&dest);
        assert!(result.is_err(), "should refuse to overwrite existing file");

        // Confirm the file was not modified.
        assert_eq!(fs::read_to_string(&dest).unwrap(), "existing content");
    }

    #[test]
    fn run_writes_non_empty_toml() {
        let dir = tempfile::tempdir().unwrap();
        let dest = dir.path().join("backup.toml");
        run(&dest).unwrap();

        let content = fs::read_to_string(&dest).unwrap();
        // At minimum the four expected sections must be present.
        for section in &["[repo]", "[backup]", "[retention]"] {
            assert!(content.contains(section), "missing section {section}");
        }
    }
}

// ─── Insta snapshot tests ─────────────────────────────────────────────────────

#[cfg(test)]
mod snapshot_tests {
    use super::render_template;

    /// Lock down the exact shape of the generated config so any formatting
    /// change shows up as an explicit snapshot diff.
    #[test]
    fn snapshot_template_typical() {
        let out = render_template("/home/yonas/projects/myapp", "yonas", "myapp");
        insta::assert_snapshot!(out);
    }

    #[test]
    fn snapshot_template_path_with_spaces() {
        let out = render_template("/home/alice/my projects/widget", "alice", "widget");
        insta::assert_snapshot!(out);
    }

    #[test]
    fn snapshot_template_root_fallback() {
        // When repo_name falls back to "backup" (e.g. cwd is "/")
        let out = render_template("/", "root", "backup");
        insta::assert_snapshot!(out);
    }
}
